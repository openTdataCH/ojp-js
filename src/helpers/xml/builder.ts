import * as OJP_Types from 'ojp-shared-types';

import { XMLBuilder } from "fast-xml-parser";
import { XML_Config } from "../../types/_all";
import { DefaultXML_Config } from "../../constants";

// TODO - keep it abstract, handle the callback if needed
function transformKeys<T extends Record<string, any>>(obj: T, path: string[] = [], callback:(key: string, value: any, path: string[]) => string): Record<string, any> {
  // Strip @_ generated by other OJP response
  if ((obj !== null) && (typeof obj === 'object') && !Array.isArray(obj)) {
    for (const key in obj) {
      if (key.includes('@_')) {
        delete obj[key];
      }
    }
  }

  return Object.entries(obj).reduce((acc, [key, value]) => {
    const newKey = callback(key, value, path);
    const newPath = path.concat([newKey]);

    acc[newKey] = (() => {
      if (value instanceof Object) {
        if (Array.isArray(value)) {
          (value as any[]).forEach((el, idx) => {
            if (el instanceof Object) {
              value[idx] = transformKeys(el, newPath, callback);
            }
          });
        } else {
          return transformKeys(value, newPath, callback);
        }
      }

      return value;
    })();
    
    return acc;
  }, {} as Record<string, any>);
}

export function buildRootXML(obj: Record<string, any>, xmlConfig: XML_Config = DefaultXML_Config, callbackTransformedObj: ((obj: Record<string, any>) => void) | null = null): string {
  const wrapperNodeName = 'OJP';

  const rootXML = buildXML(obj, wrapperNodeName, xmlConfig, (objTransformed => {
    const rootKeys = Object.keys(objTransformed);
    if (typeof objTransformed === 'object' && (rootKeys.length === 1)) {
      const rootKeyParts = rootKeys[0].split(':');
      if (rootKeyParts.length === 2) {
        // HACK - OJP v1.0 - keep the root element without namespaces
        const oldKey = rootKeys[0];
        const newKey = rootKeyParts[1];
        
        objTransformed[newKey] = objTransformed[oldKey];
        delete objTransformed[oldKey];
      }
    }

    if (callbackTransformedObj) {
      callbackTransformedObj(objTransformed);
    }
  }));

  const wrapperRootXML_Lines: string[] = [
    '<?xml version="1.0" encoding="utf-8"?>',
    rootXML,
  ];

  const wrapperRootXML = wrapperRootXML_Lines.join('\n');

  return wrapperRootXML;
}

export function buildXML(obj: Record<string, any>, wrapperNodeName: string = 'OJP', xmlConfig: XML_Config = DefaultXML_Config, callbackTransformedObj: ((obj: Record<string, any>) => void) | null = null): string {
  const objCopy = JSON.parse(JSON.stringify(obj));

  const objTransformed = transformKeys(objCopy, [wrapperNodeName], (key: string, value: any, path: string[]) => {
    // capitalize first letter
    let newKey = key.charAt(0).toUpperCase() + key.slice(1);

    // ensure namespaces
    const parentKey = path.at(-1) ?? null;
    if (parentKey !== null) {
      const tagNS_Key = parentKey.replace(/^.*:/, '') + '.' + newKey;
      const tagNS = (() => {
        const tagNSConfig = OJP_Types.OpenAPI_Dependencies.MapNS_Tags[tagNS_Key] ?? 'ojp';
        if (xmlConfig.defaultNS === tagNSConfig) {
          return '';
        }

        return tagNSConfig + ':';
      })();

      if (tagNS !== null) {
        newKey = tagNS + newKey;
      }
    }

    return newKey;
  });

  if (callbackTransformedObj) {
    callbackTransformedObj(objTransformed);
  }

  const xmlParts: string[] = [];

  // By convention
  const isRootNode = wrapperNodeName === 'OJP';
  if (isRootNode) {
    const xmlAttrs: string[] = [];
    for (const ns in xmlConfig.mapNS) {
      const url = xmlConfig.mapNS[ns];
      const attrNS = ns === xmlConfig.defaultNS ? 'xmlns' : ('xmlns:' + ns);
      const xmlAttr = attrNS + '="' + url + '"';
      xmlAttrs.push(xmlAttr);
    }

    const xmlVersionAttr = 'version="' + xmlConfig.ojpVersion + '"';
    xmlAttrs.push(xmlVersionAttr);

    xmlParts.push('<OJP ' + xmlAttrs.join(' ') + '>');
  } else {
    xmlParts.push('<' + wrapperNodeName + '>');
  }

  const builder = new XMLBuilder({
    format: true, 
    ignoreAttributes: false,
    suppressEmptyNode: true,
  });
  xmlParts.push(builder.build(objTransformed));
  
  xmlParts.push('</' + wrapperNodeName + '>');

  const xmlS = xmlParts.join('\n');

  return xmlS;
}
